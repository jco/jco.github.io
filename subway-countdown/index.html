<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <meta name="apple-mobile-web-app-capable" content="yes">

  <title>Next Trains</title>
<style type="text/css">
html {
  font-size: 48px;
}

body {
  margin: 0;
  background: white;
  color: #111;
  font-family: system-ui, sans-serif;
}

main {
  margin: 0;
}

ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

li {
  padding: 0.6rem 0.75rem;
  border-bottom: 1px solid #CCC;
  font-size: 1.2rem;
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  line-height: 1;
}

.route {
  background-color: rgb(248, 217, 74);
  color: #111;
  border-radius: 50%;
  display: inline-block;
  text-align: center;
  width: 1.4em;
  height: 1.4em;
  line-height: 1.4em;
  font-weight: bold;
}

.min, .ampm {
  font-size: 0.7em;
}

.separator {
  font-weight: 200;
  color: #AAA;
}


</style>
</head>
<body>
  <main>
    <ul id="departures"></ul>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/protobufjs/dist/protobuf.min.js"></script>
  <script type="text/javascript">
  const FEED_URL =
  "https://api-endpoint.mta.info/Dataservice/mtagtfsfeeds/nyct%2Fgtfs-nqrw";

const TARGET_STOP = "R03S"; // change to your stop

const departuresEl = document.getElementById("departures");

let FeedMessage;

async function initProto() {
  const root = await protobuf.load("gtfs-realtime.proto");
  FeedMessage = root.lookupType("transit_realtime.FeedMessage");
}

async function fetchTrains() {
  try {
    const response = await fetch(FEED_URL);
    const buffer = await response.arrayBuffer();

    const message = FeedMessage.decode(new Uint8Array(buffer));
    const now = Math.floor(Date.now() / 1000);

    const departures = [];

    message.entity.forEach((entity) => {
      if (!entity.tripUpdate) return;

      entity.tripUpdate.stopTimeUpdate.forEach((update) => {
        if (update.stopId === TARGET_STOP) {
          const timestamp = update.departure && update.departure.time;

          if (!timestamp) return;

          const secondsAway = timestamp - now;

          if (secondsAway > 0) {
            departures.push({
              route: entity.tripUpdate.trip.routeId,
              seconds: secondsAway,
              timestamp: timestamp
            });
          }
        }
      });
    });

    departures.sort((a, b) => a.seconds - b.seconds);
    render(departures.slice(0, 5));

  } catch (err) {
    console.error(err);
  }
}

function render(departures) {
  departuresEl.innerHTML = "";

  if (!departures.length) {
    departuresEl.innerHTML = "<li>No upcoming trains</li>";
    return;
  }

  departures.forEach(({ route, seconds, timestamp }) => {
    const minsAway = Math.floor(seconds / 60);
    // const secsAway = seconds % 60;

    var departureDate = new Date(timestamp * 1000);
    var hours = departureDate.getHours();
    var minutes = departureDate.getMinutes();
    var ampm = hours >= 12 ? "PM" : "AM";
    hours = hours % 12;
    if (hours === 0) hours = 12;  // 12 AM / PM instead of 0
    var departureTime = hours + ":" + (minutes < 10 ? "0" : "") + minutes;

    const li = document.createElement("li");
      li.innerHTML = `<span class="route">${route}</span> <span class="time">${departureTime} <span class="ampm">${ampm}</span> <span class="separator">&mdash;</span> ${minsAway} <span class="min">min</span></span>`;

    departuresEl.appendChild(li);
  });
}

(async () => {
  await initProto();
  await fetchTrains();
  setInterval(fetchTrains, 10000);
})();
</script>
</body>
</html>
